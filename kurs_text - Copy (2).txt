В настоящее время практически все организации стараются создавать веб-сайты, которые служат одним из основных источников как привлечения внимания клиентов, так и взаимодействия с ними. Тем не менее, с увеличением количества web-сайтов, так же возрастает и количество злоумышленников, заинтересованных в получении несанкционированного доступа к конфиденциальной информации какой-либо организации для дальнейшего осуществления вредоносных действий.
Согласно статистике, большинство компаний предпочитают использовать готовые решения по созданию сайта в виде систем управления контентом - CMS (Content Management System).
Система управления контентом – это программное обеспечение, позволяющее её пользователям создавать, модифицировать контент web-сайта и управлять им без особых требований и навыков в программировании.
Заместо того, чтобы конструировать полноценную систему для создания web-страниц самостоятельно, CMS позволяет сконцентрироваться на более важных задачах бизнеса.


Перед началом реализации сканера необходимо определиться с инструментами разработки, которые обеспечат эффективность, производительность и кроссплатформенность.
В качестве языка программирования был выбран Python, который предоставляет обширные возможности благодаря своей интерпретируемости и динамической типизации, что способствует разработке продукта с высокой скоростью. Кроме того, Python поддерживает множество библиотек и фреймворков, что делает его идеальным выбором в решении данной задачи.
Итого в работе были использованы следующие технологии:
- среда разработки Visual Studio Code;
- язык программирования Python;
- язык запросов SQL;
- система управления версиями Git;
- библиотека Requests для установления соединения с сайтами и отправки HTTP-запросов;
- библиотека BeautifulSoup для парсинга HTML документов;
- библиотека Selenium для имитации действий веб-браузера, что обеспечивает возможность отправки запросов сайтам так, как если бы они происходили от реального пользователя;
- библиотека Colorama для добавления цвета в консольный интерфейс, что позволяет улучшить визуальное восприятие и удобство использования консольных приложений;
- микрофреймворк Flask для создания веб-сайта, предназначенного для тестирования сканера.
Благодаря вышеперечисленным технологиям удалось создать полнофункциональный и мощный инструмент для анализа уязвимостей веб-сайтов, который обладает широкими возможностями и высокой эффективностью.


Разработка сканера 
Проектирование приложения
Для разработки комплексного и эффективного приложения требовалось спроектировать гибкую и расширяемую архитектуру. Организация архитектуры приложения частично строилась на основе идеи паттерна MVC (Model, View, Controller). Основная суть данного паттерна заключается в разделении программы на отдельные логические компоненты, каждый из которых выполнет только тот функционал, который ему был присвоен. Засчёт модульности улучшается организация и, соответственно, читаемость кода, а следовательно так же повышается эффективность при разработке приложения благодаря упрощению поддержки и внесению изменений. При проектировании сканера были созданы отдельные самостоятельные модули: представления(Views), управления(Controllers) и вспомогательные инструменты(Utils).
Views отвечает за визуализацию данных и взаимодействие с конечным пользователем для вызова функций сканера. Этот модуль хранит в себе класс Menu, ответственный как за отображение данных, так и за взаимодействие с модулем Controllers.  
Модуль Controllers хранит в себе основной функционал сканера и содержит все функции и методы, необходимые для обработки данных, управления процессом сканирования и взаимодействия с другими модулями. Данный модуль содержит такие классы как: 
- basic Wordpress scanner;
- brute-force attack;
- vulnerabilities scanner;
- sql injections scanner;
- ports scanner;
- web-crawler;
- fuzzer.
Реализацию каждого из этих основополагающих классов мы рассмотрим далее. 
Модуль Utils представляет собой коллекцию вспомогательных функций и инструментов, которые используются в различных частях сканера. В этом модуле содержится утилита для работы и хранения файлов, парсер аргументов с консольного интерфейса, а также другие вспомогательные классы и методы, которые не относятся напрямую к основной логике сканера, но необходимы для его корректной работы.
Также были созданы дополнительно вспомогающие компоненты для полноценной работы приложения: область хранения результатов  работы  сканера по каждому из доменов (Public), область хранения базы данных (DB) 
Точкой входа в программу является файл "main.py", внутри которого собираются все компоненты воедино и в последствии запускается непосредственно сам сканер с его графической оболочкой.
Схема архитектуры приложения представлена на рисунке 1.
Рисунок 1. Схема архитектуры приложения


Интерфейс приложения
Так как специфика программы подразумевает, было принято решение реализовать только консольный интерфейс программы.
При запуске консольного приложения программа потребует обязательного ввода URL web-сайта, для дальнейших операций с ним. При игнорировании данного требования программа будет прекратит свою работу и представит справку с основными флагами и их назначениями. После успешного ввода ввалидных данных программа в первую очередь проверит данный web-сайт на наличие системы управления контентом на платформе Wordpress. Так как все внутреннние алгоритмы работы спроектированы именно под эту CMS, то данная проверка является вполне логичной для устранения дальнейших ошибок.
После успешной проверки web-сайта перед пользователем открываются такие разделы, как:
- Basic Scan; 
- Brute-force;
- Vulnerabilities Scan;
- Ports Scan;
- Crawler;
- Fuzzing; 
- Show report;
- Help;
- Exit.
Каждый раздел дополнительно пронумерован в консольном отображении для удобства навигации при выборе необходимой функции. Для перехода в определённый раздел, требуется ввести в поле ввода консоли его порядковый номер. В случае, если внутри раздела присутствуют подразделы то к ним  . Пример такого отображения проилюстрован на рисунке 220.
(рисунок)
При выборе раздела Help, в консоли отобразится полная справка по каждому из доступных разделов, подробно описывая весь внутренний функционал.
При выборе раздела Show report, в консоли будет отображен весь актуальный отчёт на момент работы сканера.
При выборе раздела Exit, программа завершит свою работу, отобразив перед этим авторские данные.
Тестирование приложения
Тестирование программного обеспечения является ключевым этапом перед завершением и публикацией продукта, позволяя ещё на стадии разработки выявить ранее непредвиденные ошибки в работе программы.
Однако проведение тестов работоспособности сканера на web-сайте без согласия владельцев является противоправным действием. В связи с этим было принято решение развернуть на собственном локальном сервере полноценно работающий web-сайт на базе Wordpress и неоснованный на CMS.  


Установка локального сервера на базе Wordpress
Для тестирования большей части функционала сканера, требуется подобрать программную среду для веб-разработки. На рынке цифровых продуктов существует большое множество решений, таких как OSPanel, Local, XAMPP и другие.
Рассмотрим и применим Local как среду разработки и дальнейшего тестирования по следующим причинам:
- бесплатность;
- полная сфокусированность на платформе Wordpress;
- автоматическая установка всех требуемых компонентов для успешной работы локального сайта;
- коллекция предустановленных инструментов для удобного управления сайтом.

Для успешного развёртывания сайта достаточно при установке указать требуемую нам версию PHP и MySQL, а также выбрать один из доступных веб-серверов - nginx или Apache.
(Рисунок)
Среда веб-разработки Local попросит нас ввести название сайта и его полное доменное имя - "curse.local".
Создадим заведомо уязвимую к атаке грубой силой привилегированную учётную запись вида:
- username: admin;
- password: admin.
Скачивание последней версии Wordpress и его начальная инициализация происходит автоматически в фоновом режиме. 
Далее, после удачного этапа установки, требуется наполнить сайт уязвимым содержимым с помощью встроенного интерфейса Wordpress. Чтобы попасть в приборную панель сайта, необходимо авторизоваться под видом администратора, учётную запись которого мы создавали ранее. В Local предусмотрена возможность входа на сайт администратора без необходимости ввода логина и пароля.
Приступим к выполнениям этапов, такие как:
- создание несколько учётных записей со слабыми и не только паролями;
- скачивание и установка несколько доступных тем из открытого каталога тем Wordpress;
- скачивание, установка и настройка различных плагинов из доступного каталога плагинов Wordpress.

После полной настройки сайта можно приступать к тестированию работоспособности сканера. К проверке будут подлежать все доступные модули для удостоверения в их корректной и исправной работе.
При запуске программы сканера, укажем домен локального сайта и добавим флаг '-s' для работы в режиме HTTPS.
Запрос будет таким: "python ./src/main.py curse.local -s",
где файл "main.py" является точкой входа в программу выполнения.
В случае же, если мы укажем пустое или не ввалидное название домена, или добавим не существующий флаг, программа завершится с объяснением причины останова - ввиду ошибки целостности домена или ошибки распознования аргументов соответственно.
(рисунок)
В первую очередь, при помощи консольного интерфейса подтвердим желание проверить наш сайт на присутствие Wordpress платформы. В нашем случае, сканер успешно подтвердил факт наличия на сайте следов Wordpress, продолжив выполнение программы дальше. В противном случае, программа должна отработать исключение с дальнейшем завершением работы в связи с отсутствием платформы Wordpress на сайте. Перед доступом к главному меню, программа автоматически проверит, настроен ли сайт или ещё в процессе установки. Также в фоновом режиме проверяются токены доступа к API сервису по выявлению уязвимостей WPS Scan.
После попадания в основное меню программы по выбору модулей сканера, вызвав опцию "Show report" удостоверимся, что на данный момент у нас нет никакой информации по сайту. После отправки запроса на показ отчёта, программма отображает данные в консоли, а так же генерирует текстовый файл с актуальной на данный момент информацией о содержимом домена. Сгенерированный отчёт доступен по адресу: "./src/public/<URL_NAME>/report-<DATE_TIME>.txt", где "URL_NAME" - название исследуемого сайта, "DATE_TIME" - время и дата создания документа. Так как при старте программы, не был включен дополнительный флаг "--user_agent" по определению пользовательского агента при дальнейшем сканировании, программа назначила нам случайный из списка в файле, доступного по пути: "./src/db/user-agents.ini". 
(рисунок пустого репорта)
Далее, воспользуемся основным модулем сканирования, выбрав первую опцию "Scan" из доступных. Ожидаемым исходом работы данного модуля является:
- определение установленной версии Wordpress;
- определение активированной темы сайта;
- определение активированных плагинов;
- нахождение основных компонентов сайта;
- детектирование зарегестрированных пользователей сайта;
- определение backup файлов.

Результат работы сканера представлен на рисунке :
(рисунок)
Результат работы модуля "Scan"

С помощью модуля Brutforce, воспользуемся атакой методом грубой силой и попытаемся определить учётные данные пользователей для прохождения аутентификации на сайте. При переборе паролей воспользуемся встроенной базой данных по умолчанию, а список логинов применим из найденных предыдущим модулем "Scan". 
Ожидаемым исходом работы данного модуля является:
- 
- детектирование учётной записи с административными привилегиями
Результат работы сканера представлен на рисунке :
(рисунок) Результат работы после модуля "Brutforce"

(рисунок) Результат работы после модуля "Scan Ports"
(рисунок) Результат работы после модуля "Crawler"
(рисунок) Результат работы после модуля "Fuzzing"
Заключительным этапом тестирования станет проверка модуля по выявлению уязвимостей. После того, как с помощью сканера были найдены все доступные и 
-активные темы,
- плагины, 
- уязвимые к sql инъекциям формы
-  и версия Wordpress сайта, 
Результат работы после модуля "Check Vulnerability"

После выполнения тестирования на признак валидной работы сканера с помощью локального сайта на платформе Wordpress был сделан вывод об успешной работе всех доступных модулей программы.














Установка локального сервера
Для тестирования SQL инъекций был спроектирован дополнительный сервер, написанный с помощью фреймворка Flask на языке Python.
Flask - это облегчённый фреймворк предназначенный для создания веб приложений. Он классифицируется как микрофреймворк, потому что изначально не требует дополнительных сторонних библиотек и специальных подключенных инструментов.
Засчёт этого с помощью него можно написать только необходимую логику для сервера.

Также была спроектирована реляционная база данных на основе СУБД SQLite.
SQLite - это компактная система управления базами данных. В отличие от большинства других СУБД, SQLite не требует отдельного процесса сервера и поэтому позволяет хранить всю базу данных в одном файле. Это делает SQLite отличным выбором в случаях, когда необходима простая и легковесная база данных без дополнительных затрат ресурсов на поддержку сервера.
Было создано две таблицы "users" и "CVV".
- Таблица "users' содержит в себе 3 поля - "username", "password", "role". Таблица хранит записи с именем пользвателя, его паролем и ролью соответственно.
- Таблица "CVV" содержит в себе 2 поля - "user_id" и "cvv". Она прикрепляет к каждому пользователю его секретный CVV код. Таблица подразумевается приватной и не должна открываться доступом извне.

Заполним созданные таблицы заранее подготовленными записями. Введём 5 различных пользователей сайта с разными ролями, пароли будут храниться в виде хеша MD5 для дополнительной безопасности в случае утечки базы данных. Также заполним таблицу "CVV" записями, прикреплёнными к каждому из созданных раннее пользователей.

При открытии с помощью браузера основного адреса сайта "localhost:5000/", открывается примитивная html страница с доступом к двум формам для заполнения:
- Форма "Login", для авторизации пользователя.
- Форма "List Users", для вывода всех пользователей определённой роли на сайте.
Рассмотрим каждую из них подробнее.
Для успешного заполнения формы Login требуется ввести два поля - "Username" и "Password". После нажатия кнопки ниже "Login", формируется GET запрос на сервер с введёнными данными. Конечный запрос будет выглядеть так: "localhost:5000/login?username=<ДАННЫЕ>&password=<ДАННЫЕ>", где в местах угловых скобок будут введены данные поля "Username" и "Password" соответственно.

Для успешного заполнения формы "List Users" достаточно ввести лишь одно поле - "Role". После нажатия кнопки "List Users", также формируется GET запрос на сервер. Конечный запрос будет выглядеть так: "localhost:5000/users?role=<ДАННЫЕ>", где заместо данных в угловых скобках будут введены данные из поля "Role".

Основная ошибка разработчиков при обработке запросов пользователей является прямое внедрение данных в SQL запрос без каких-либо этапов валидации. Спроектируем обработчик пользовательских запросов на сервере именно с этой уязвимостью для дальнейшего тестирования.

При обработке запроса "Login", сервер считывает оба поля "username" и "password", хеширует введённый пароль в MD5 и сразу же генерирует SQL запрос для СУБД.
Итоговый запрос: "SELECT * FROM users WHERE username = ? and password = ?",
где заместо вопросительных знаков будут введены соответствующие им данные.
Если такой пользователь существует, то сервер отправляет ответ с успешной авторизацией, сообщая актуальную роль у данного пользователя.

При обработке запроса "List Users", сервер считывает поле "role" и в случае, если запрашивается список пользователей с ролью "admin", сервер возвращает отказ в обработке данного запроса. Это спроектировно для сокрытия актуальных имен пользователей с привилегиями администратора сайта в целях безопасности. В остальных же случаях будет сгенерирован SQL запрос в виде:
"SELECT username, role FROM users WHERE role = '{0}'", 
где заместо фигурных скобок будет введена роль из полученого GET запроса пользователя.

Протестируем сервер вначале с корректными данными для удостоверения в правильной работе сайта.

Ответ GET запроса формы "Login" при верно введённых данных имени пользователя и его пароля.
(изображение 1) 
Ответ GET запроса формы "Login" при неверно введённых данных имени пользователя или пароля.
(изображение 2)
Ответ GET запроса формы "List Users" при верно введённой доступной роли.
(изображение 3) 
Ответ GET запроса формы "List Users" при введённой роли "admin".
(изображение 4) 

После того, как мы удостоверились, что сервер обрабатывает наши запросы исправно, воспользуемся техниками SQL инъекций.

Один из самых простых в реализации приёмов на проверку сервера, обрабатывает ли он входную строку перед созданием SQL запроса, является выставление одинарной кавычки в одно из полей ввода какой-либо формы.
Попробуем в форме "List Users" ввести в поле "Role" дополнительно под конец одинарную кавычку. Конечный GET запрос на сервер будет выглядеть так: "localhost:5000/users?role=user'".
Так как локальный сервер уязвим к данной атаке, то этот запрос напрямую перейдёт в тело SQL запроса, который в итоговом виде будет таким: "SELECT username, role FROM users WHERE role = user'".
Из-за допуска лишней одинарной кавычки в SQL запрос, СУБД возвращает ответ с указанием ошибки при вводе SQL запроса, так как такой запрос недопустим.
( Рисунок 5 )
Что самое примечательное, ответ о некорректности SQL запроса передаётся прямиком к конечному пользователю, засчёт чего можно сделать вывод, что именно данная форма на сайте уязвима к SQL инъекциям.
После того, как мы убедились в уязвимости, далее можно с помощью знаний языка SQL, выстраивать конечный запрос таким образом, чтобы сервер нам выдавал конфиденциальную информацию, даже не предназначенную для нас.
Например, мы знаем, что форма "List Users" проводит валидацию введённой роли, отказывая в выводе всех пользователей с администраторскими привилегиями.
Но, если мы составим запрос таким образом: "localhost:5000/users?role=user'+OR+'1'%3D'1", добавив оператор OR и операцию 1=1, мы можем вывести список всех пользователей и обойти ограничение на вывод списка для роли admin.
Пробел и символ "=" в конечном URL заменяется на "+" и "%3D" соответственно для однозначности при кодировки. 
В конце одинарная кавычка не выставляется для избежания ошибок, так как она ставится автоматически внутри сервера.
( Рисунок 6 )

Также можем с помощью SQL инъекции проверить уязвимость в выдаче информации из других таблиц базы данных, не предназначенных для этого.
Составим следующий запрос: "localhost:5000/users?role=user'+UNION+ALL+SELECT+*+from+CVV--",
где UNION ALL отвечает за объединение таблиц, а символы "--" отвечают за комментирование строки на языке SQL.
Полученный результат изображен на рисунке *.
( Рисунок 7 )

Убедившись в том, что наш локальный сайт работает с явными упущениями в безопасности в виде SQL уязвимостей, мы можем протестировать наш модуль сканера, отвечающий за выявление возможностей SQL инъекций.

При запуске программы сканера, укажем домен локального сайта без добавления дополнительных аргументов.
Конечный запрос будет таким: "python ./src/main.py localhost:5000",
где файл "main.py" является точкой входа в программу выполнения.

Так как текущий сайт не создан на основе платформы Wordpress, откажемся от дополнительной проверки.
Программа выдаст предупреждение, что не вся функциональность сканера будет доступна в исправном режиме. Поэтому воспользуемся лишь некоторыми функциями, а именно:
- определение открытых портов и служб, работающих на этом сервере
- определение форм сайта, доступных для проведения тестирования на уязвимость к SQL-инъекциям
- проверка найденных форм на уязвимость к SQL-инъекциям

После поочерёдного тестирования каждой из вышеперечисленных функций убедимся, что сканер действительно определил форму ‘List Users’, а именно адрес ‘localhost:5000/users?role=’, на уязвимость к SQL-инъекциям.
(рисунок) Результат работы сканера

Заключение

https://rushter.com/blog/detecting-sql-injections-in-python/